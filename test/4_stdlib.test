#!./run
# test the Lisp standard library
# leg20231129
tap 16

export FLISPRC=../lisp/core.lsp
# Note: nested requiring stopped working
stdlib() { IN="(require 'stdlib) $IN" flisp_expr "$@"; }
stdlib() { IN="(require 'flisp) (require 'stdlib) $IN" flisp_expr "$@"; }
stdlib_err() { IN="(require 'stdlib) $IN" flisp_err "$@"; }

# atom
IN='(atom 0)' OUT=t
stdlib 1; ok atom-1 number is atom

IN='(atom "a")' OUT=t
stdlib 1; ok atom-2 string is atom

IN="(atom 'symbol)" OUT=t
stdlib 1; ok atom-3 symbol is atom

IN='(atom nil)' OUT=t
stdlib 1; ok atom-4 nil is atom

IN="(atom '(0 'b))" OUT=nil
stdlib 1; ok atom-5 list is not atom

# zerop
IN='(zerop 0)' OUT=t
stdlib 1; ok zerop-1 0 is zero

IN='(zerop 1)' OUT=nil
stdlib 1; ok zerop-2 1 is not zero

# equal
true; ok equal \# TODO

# append
IN='(append)' OUT="nil"
stdlib 1; ok append-1 append nothing is nil

IN='(append 1)' OUT="1"
stdlib 1; ok append-2 append atom is atom

IN="(append '(1 2 3))" OUT="(1 2 3)"
stdlib 1; ok append-3 append list is list

IN="(append '(1 2 3) 1)" OUT="(1 2 3 . 1)"
stdlib 1; ok append-4 append list atom is dotted list

IN="(append '(1 2 3) '(a b c))" OUT="(1 2 3 a b c)"
stdlib 1; ok append-5 append list list is list

IN="(append 1 1)" ERR="(append arg args) - arg must be list" OBJ=
stdlib_err 1; ok append-6 append atom any errs

# print
IN='(write "ans\\wer" :readably t)' OUT='"ans\\wer""ans\\wer"'
stdlib 1; ok print-1 write string escaped

# princ
IN='(write "ans\\wer")' OUT='ans\wer"ans\\wer"'
stdlib 1; ok princ-1 write string unescaped

# Local Variables:
# mode: sh
# End:
