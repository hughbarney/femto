Turning Tiny Lisp into fLisp
============================

Femto's Lisp is not Tiny Lisp anymore. It should get it's own live,
e.g. as 'fLisp' (femtolisp is already taken by a 10^6f Lisp)


Design principles;

- Less C, more Lisp, provide only the minimum C primitives and do the
  rest with libraries.
- If a function is needed, emulate
  - first Elisp
  - then Common Lisp
- Emulated function should have the same interface as the original,
  but can/should be as simplified as possible.


Roadmap:

- Finish basic refactoring, in progress.
  - replace string.ref with string.substring, done
  - documentation, in progress
- Improve substring to handle start/end gracefully.
- Align remaining string functions with Elisp.
- Align buffers and windows.
- Documentation
- Finish exception handling.
- load via buffers.
- Integer arithmetic.


Ideas:

- Add (nullp) as primitive: it is much faster and memory efficient
  then (eq nil o) .
- fLisp should/need not know about files: it already has buffers.
  - (load "filename") loads filename into a buffer and eval.
  - Remove file handling from C.
  - Testing show following handicaps:
    - (eval-block) inserts output into current buffer, which destroys
      the Lisp code in it.
- Swap out Tiny Lisp floating point arithmetic. with signed integer we
  barely need + and *.
  - Implement primitive (add a b), (*/mod a b c) (lognot a).
  - Implement +, -, *, / % in Lisp with the help of (reduce),
  - Minimal set in core, others in stdlib.
 - Exceptions
   - user exceptions are already implemented with (signal) in an Elisp
     conformant way.
   - Internal errors should use the (signal) signature, error handling
     should adapt.
   - (trap) is a start, but not ideal.
     - we want the signaled object.
     - we must handle double exceptions/signals.
   - Implement (condition-case).
- Keymaps
  - Each buffer should (potentially) have its own keymap, so we can
    implement all kind of modes.
- Independent, modular interpreter.
  - Launch as many interpreters as needed, a start has been made with
    the Interpreter struct.
  - call as of:
    main.c:
    Interp *flisp = createInterp(SIZE, addons);
    call_lisp(flisp, "lisp code");
  - addons is an array of external primitives to be integrated.
  - headers.h should be split into individual headers.


Reasoning:

Hugh Barney alread expanded Tiny Lisp substantially:

- New type: string
- Loading Lisp from files
- Reading/Writing Lisp input/output from "streams".
- Editor functions

Georg Lehner added:
- batch mode
- debug mode
- init file provisioning

Georg Lehner considers:
- Tiny Lisp segfaults reproducible, e.g. with some macros.
- cond and if are redundant
- cond is not working correctly
- atom is seldom used, consp (the negation) however often, so consp
  should be the primitive and atom derived from it.
- The std library is somewhat arbitrary, some of it's features is not
  even used.  It should be moved out of C code.

