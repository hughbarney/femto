<!DOCTYPE html>
<html lang="en" xml:lang="en">
  <head>
    <title>fLisp Manual</title>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <meta content="Emacs, editor, Lisp, tiny, reference, manual" name="keywords" />
    <meta content="Reference and user manual for the fLisp programming language and interpreter" name="description" />
    <meta content="Georg Lehner &lt;jorge@magma-soft.at&gt;" name="author" />
    <meta content="2023" name="copyright" />
  </head>
  <body>
    <h1>fLisp Manual</h1>

    <aside>
      <p>Table of Contents</p>
      <ol>
	<li><a href="#introduction">Introduction</a></li>
	<li><a href="#lisp">Lisp</a></li>
	<ol>
	  <li><a href="#notation">Notation Convention</a></li>
	  <li><a href="#interpreter">fLisp Interpreter</a></li>
	  <li><a href="#syntax">Syntax</a></li>
	  <li><a href="#objects_and_data_types">Objects and Data Types</a></li>
	  <li><a href="#evaluation">Environments, Functions, Evaluation</a></li>
	  <li><a href="#primitives">Primitives</a></li>
	  <ol>
	    <li><a href="#interp_ops">Interpreter Operations</a></li>
	    <li><a href="#object_ops">Object Operations</a></li>
	    <li><a href="#string_ops">String Operations</a></li>
	    <li><a href="#arithmetic_ops">Arithmetic Operations</a></li>
	  </ol>
	</ol>
	<li><a href="#editor">Editor Extension</li>
	<ol>
	  <li><a href="#buffers">Buffers</a></li>
	  <ol>
	    <li><a href="#text">Text manipulation</a></li>
	    <li><a href="#selection">Selection</a></li>
	    <li><a href="#cursor">Cursor Movement</a></li>
	    <li><a href="#buffer_management">Buffer management</a></li>
	  </ol>
	  <li><a href="#ui">User Interaction</a></li>
	  <ol>
	    <li><a href="#windows">Window Handling"</a></li>
	    <li><a href="#message_line">Message Line</a></li>
	    <li><a href="#keyboard">Keyboard Handling</a></li>
	    <li><a href="#programming_system">Programming and System Interaction</a></li>
	  </ol>
	</ol>
	<li><a href="#exceptions">Error Handling</a></li>
	<li><a href="#embedding">Embedding fLisp</a></li>
	<li><a href="#implementation">Implementation Details</a></li>
	<ol>
	  <li><a href="#gc">Garbage Collection</a></li>
	  <li><a href="#memory">Memory Usage</a></li>
	  <li><a href="#future">Future Directions</a></li>
	</ol>
      </ol>
    </aside>

    <h3 id="introduction">Introduction</h3>
    <blockquote>
      <p>
	A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing
	left to take away.
      </p>

      <p>&mdash; Antoine de Saint-Exupery</p>
    </blockquote>
    <p>
      <i>fLisp</i> is a tiny yet practical interpreter for a dialect of the Lisp programming language. It is used as
      extension language for the <a href="https://github.com/matp/tiny-lisp">Femto</a> text editor.
    </p>
    <p>
      <i>fLisp</i> originates from <a href="https://github.com/matp/tiny-lisp">Tiny-Lisp by matp </a>(pre 2014), was
    integrated into <a href="https://github.com/hughbarney/femto">Femto</a> by Hugh Barnes (pre 2016) and compacted by
    Georg Lehner in 2023.
    </p>
    <p>This is a reference manual. If you want to learn about Lisp programming use other resources eg.</p>
    <ul>
      <li>The <a href="lisp-lang.org">Common Lisp</a> web site,</li>
      <li>
	<a href="https://www.gnu.org/software/emacs/manual/html_node/eintr/index.html">An Introduction to Programming in
	  Emacs Lisp</a> or
      </li>
      <li><a href="https://www.scheme.org/">The Scheme Programming Language</a>.</li>
    </ul>
    <h3 id="lisp">Lisp</h3>
    <h4 id="notation">Notation Convention</h4>

    <p>
      <i>fLisp</i> fancies to converge toward Emacs Lisp. Function descriptions are annotated with a compatibility
      scale:
    </p>
    <dl>
      <dt><u>C</u></dt>
      <dd>Interface compatible, though probably less featureful.</dd>
      <dt><u>D</u></dt>
      <dd>Same name, but different behavior.</dd>
      <dt><u>S: <var>name</var></u></dt>
      <dd><var>name</var> is a similar but not compatible function in Emacs Lisp.</dd>
      <dt><u>B</u></dt>
      <dd>Buggy/incompatible implementation.</dd>
    </dl>
    <p>Annotation is omitted if the function does not exist in Emacs Lisp.</p>

    <p>We use the following notation rule for the <i>fLisp</i> syntax:</p>
    <dl>
      <dt><code><var>name</var></code></dt>
      <dd>
	<var>name</var> is the name of a variable. In Markdown documents it is shown with guillemots, like
	this <code>«name»</code>.</dd>
      <dt><code>[text]</code></dt>
      <dd><code>text</code> can be given zero or one time.</dd>
      <dt><code>[text..]</code></dt>
      <dd><code>text</code> can be given zero or more times.</dd>
      <dt><q><code> </code></q></dt>
      <dd>A single space is used to denote an arbitrary sequence of whitespace.</dd>
    </dl>

    <p>Notes:</p>
    <ul>
      <li>
	<i>fLisp</i> does not use <code>[</code>square brackets<code>]</code> and double-dots <code>..</code> as
	syntactical elements.
      </li>
      <li>String and number notation and formatting conventions are the same as in the C language</li>
    </ul>
    
    <h4 id="interpreter">fLisp Interpreter</h4>

    <p>When <i>fLisp</i> is invoked it follows a three step process:</p>
    <ol>
      <li>Read: program text is read in and converted into an internal representation.</li>
      <li>Evaluate: the internal representation is evaluated</li>
      <li>Print: the result of the evaluation is returned to the invoker.</li>
    </ol>
    <p>
      Core functions of the language operate on built-in objects only. <i>fLisp</i> is extended with additional
      functions in order to interact with editor related objects. With respect to the interpreter, extension functions
      behave the same as core functions.
    </p>

    <h4 id="syntax">Syntax</h4>

    <p>
      Program text is written as a sequence of symbolic expressions - <abbr><dfn>sexp</dfn></abbr>&#39;s - in
      parenthesized form. A sexp is either a single object or a function invocation enclosed in parens. Function
      invocations can be infinitely nested.
    </p>
    <p>The following characters are special to the reader:</p>
    <dl>
      <dt><code>(</code></dt>
      <dd>Starts a function invocation, <i>list</i> or <i>cons</i> object (see <a href="#objects_and_data_types">Objects
      and Data Types</a>).</dd>
      <dt><code>)</code></dt>
      <dd>Finishes a function invocation, <i>list</i> or <i>cons</i> object</dd>
      <dt><code>&quot;</code></dt>
      <dd>Encloses strings.</dd>
      <dt><code>&#39;</code></dt>
      <dd>With a single quote prefix before a <abbr>sexp</abbr>, the <abbr>sexp</abbr> is expanded
      to <code>(quote <var>sexp</var>)</code> before it is evaluated.</dd>
      <dt><code>.</code></dt>
      <dd>The expression<code> (<var>a</var> . <var>b</var>)</code> evaluates to a <i>cons</i> object, holding the
      objects <var>a</var> and <var>b</var>.</dd>
    </dl>
    <p>Numbers are represented in decimal notation.</p>
    <p>A list of objects has the form:</p>
    <blockquote>
      <code>([<var>element</var> ..])</code>
    </blockquote>
    <p>A function invocation has the form:</p>
    <blockquote>
      <code>(<var>name</var> [<var>param</var> ..])</code>
    </blockquote>
    <p>There are two predefined objects. Their symbols are:</p>
    <dl>
      <dt><code>nil</code></dt>
      <dd>
	represents: the empty list: <code>()</code>, the end of a list marker or the false value in logical operations.
      </dd>
      <dt><code>t</code></dt>
      <dd><q>true</q>, a predefined, non-false value.</dd>
    </dl>

    <h4 id="objects_and_data_types">Objects and Data Types</h4>

    <p><i>fLisp</i> objects have exactly one of the following data types:</p>
    <dl>
      <dt><dfn>number</dfn></dt>
      <dd>
	<a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">double precision floating point
	  number.</a>
      </dd>
      <dt><dfn>string</dfn></dt>
      <dd>character array.</dd>
      <dt><dfn>cons</dfn></dt>
      <dd>object holding two pointers to objects.</dd>
      <dt><dfn>symbol</dfn></dt>
      <dd>string with restricted character set: <code>[A-Z][0-9][a-z]!#$%&amp;*+-./:&lt;=&gt;?@^_~</code></dd>
      <dt><dfn>lambda</dfn></dt>
      <dd>anonymous function with parameter evaluation</dd>
      <dt><dfn>macro</dfn></dt>
      <dd>anonymous function without parameter evaluation</dd>
    </dl>
    <p>
      Objects are immutable, functions either create new objects or return existing ones.
    </p>
    <p>Characters do not have their own type. A single character is represented by a <i>string</i> with length one.</p>

    <h4 id="evaluation">Environments, Functions, Evaluation</h4>

    <p>
      All operations of the interpreter take place in an environment. An <dfn>environment</dfn> is a collection of named
      objects. The object names are of type symbol.  An object in an environment is said to
      be <dfn>bound</dfn> to its name. Environments can have a parent.  Each <i>fLisp</i> interpreter starts with
      a <dfn>root</dfn> environment without a parent.
    </p>
    <p>
      lambda and macro objects are functions. They have a parameter list and a sexp as body. When functions are invoked
      a new environment is created as child of the current environment.  Functions receive zero or more objects from the
      caller.  These are bound one by one to the symbols in the parameter list in the new environment.
    </p>
    <p>lambdas return the result of evaluating the body in the new environment.</p>
    <p>
      macros first evaluate the body in the calling environment. The resulting sexp is evaluated in the new environment
      and that result is returned.  macro bodies are typically crafted to return new sexp's in terms of the
      parameters.</p>
    <p>
      When a sexp is evaluated and encounters a symbol it looks it up in the current environment, and
      then recursively in the environments from which the lambda or macro was invoked.  The symbol
      of the first found binding is then replaced by its object.
    </p>
    <p>
      <i>fLisp</i> counts with a set of built-in functions called <dfn>primitives</dfn>. They are grouped in the manual
      by the type of objects they operate on. The primitives are bound in the global environment to the names under
      which they are described.
    </p>

    <h4 id="primitives">Primitives</h4>

    <h5 id="interp_ops">Interpreter Operations</h5>

    <dl>
      <dt><code>(progn[ <var>expr</var>..])</code></dt>
      <dd>
	Each <var>expr</var> is evaluated, the value of the last is returned. If no <var>expr</var> is
	given, <code>progn</code> returns <code>nil</code>.
      </dd>
      <dt><code>(cond[ <var>clause</var>..])</code></dt>
      <dd>
	Each <var>clause</var> is of the form <code>(<var>pred</var>[ <var>action</var> ..])</code>. <code>cond</code>
	evaluates each <var>clause</var> in turn. If <var>pred</var> evaluates to <code>nil</code>, the
	next <var>clause</var> is tested. If <var>pred</var> evaluates not to <code>nil</code> and if there is
	no <var>action</var> the value of <var>pred</var> is returned, otherwise <code>(progn <var>action</var> ..)</code>
	is returned and no more <var>clause</var>s are evaluated.
      </dd>
      <dt><code>(setq <var>symbol</var> <var>value</var>[ <var>symbol</var> <var>value</var>..])</code></dt>
      <dd>
	Create or update named objects: If <var>symbol</var> is the name of an existing named object in the current or a
	parent environment the named object is set to <var>value</var>, if no symbol with this name exists, a new one is
	created in the current environment. <code>setq</code> returns the last <var>value</var>.
      </dd>
      <dt><code>(lambda <var>params</var> <var>body</var>)</code></dt>
      <dd>
	Returns a <var>lambda</var> function which accepts 0 or more arguments, which are passed as list in the
	parameter <var>params</var>.
      </dd> 
      <dt><code>(lambda ([<var>param</var> ..]) <var>body</var>)</code></dt>
      <dd>
	Returns a <var>lambda</var> function which accepts the exact number of arguments given in the list
	of <var>param</var>s.
      </dd>
      <dt><code>(lambda (<var>param</var>[ <var>param</var>..] . <var>opt</var>) <var>body</var>)</code></dt>
      <dd>
	Returns a <var>lambda</var> function which requires at least the exact number of arguments given in the list
	of <var>param</var>s. All extra arguments are passed as a list in the parameter <var>opt</var>.
      </dd>
      <dt><code>(macro <var>params</var> <var>body</var>)</code></dt>
      <dt><code>(macro ([<var>param</var> ..]) <var>body</var>)</code></dt>
      <dt><code>(macro (<var>param</var>[ <var>param</var><..] . <var>opt</var>) <var>body</var>)</code></dt>
      <dd>
	These forms return a macro function. Parameter handling is the same as with lambda.
      </dd>
      <dt><code>(quote <var>expr</var>)</code></dt>
      <dd>Returns <var>expr</var> without evaluating it.
      </dd>
      <dt><code>(signal <var>type</var> <var>list</var>)</code></dt>
      <dd>Throws an exception, stopping any further evaluation.  Exceptions can be typed via the symbol <var>type</var>
	and must contain a list of exception related objects.  <code>(signal 'error 'nil)</code> is probably the
	simplest signal.</dd>
    </dl>

    <h5 id="object_ops">Object Operations</h5>

    <dl>
      <dt><code>(null <var>object</var>)</code></dt>
      <dd>Returns <code>t</code> if <var>object</var> is <code>nil</code>, otherwise <code>nil</code>.</dd>
      <dt><code>(symbolp <var>object</var>)</code></dt>
      <dd>Returns <code>t</code> if <var>object</var> is of type symbol, otherwise <code>nil</code>.</dd>
      <dt><code>(symbol-name <var>object</var>)</code></dt>
      <dd>If <var>object</var> is of type symbol return its value as string.</dd>
      <dt><code>(numberp <var>object</var>)</code></dt>
      <dd>Returns <code>t</code> if <var>object</var> is of type number, otherwise <code>nil</code>.</dd>
      <dt><code>(stringp <var>object</var>)</code></dt>
      <dd>Returns <code>t</code> if <var>object</var> is of type string, otherwise <code>nil</code>.</dd>
      <dt><code>(consp <var>object</var>)</code></dt>
      <dd>Returns <code>t</code> if <var>object</var> is of type cons, otherwise <code>nil</code>.</dd>
      <dt><code>(cons <var>car</var> <var>cdr</var>)</code></dt>
      <dd>Returns a new cons with the first object set to the value of <var>car</var> and the second to the value of <var>cdr</var>.</dd>
      <dt><code>(car <var>cons</var>)</code></dt>
      <dd>Returns the first object of <var>cons</var>.</dd>
      <dt><code>(cdr <var>cons</var>)</code></dt>
      <dd>Returns the second object of <var>cons</var>.</dd>
      <dt><code>(eq <var>a</var> <var>b</var>)</code></dt>
      <dd>Returns <code>t</code> if <var>a</var> and <var>b</var> evaluate to the same object, <code>nil</code> otherwise.</dd>
      <dt><code>(print <var>object</var>)</code></dt>
      <dd>
	Formats <var>object</var> into a string which can be read by the reader and returns it. As a side effect, the
	string is printed to the output stream with a leading and a closing newline. <code>print</code> escapes quotes
	in strings with a backslash.
      </dd>
      <dt><code>(princ <var>object</var>)</code></dt>
      <dd>
	Formats <var>object</var> into a string and returns it, As a side effect, the string is printed to the output
	stream.
      </dd>
    </dl>

    <h5 id="string_ops">String Operations</h5>

    <dl>
      <dt><code>(string.length <var>string</var>)</code></dt>
      <dd>Returns the length of <var>string</var> as a <i>number</i>.</dd>
      <dt><code>(string.substring <var>string</var> <var>start</var> <var>end</var>)</code></dt>
      <dd>
	Returns the sub string from <var>string</var> which starts with the character at index <var>start</var> and ends
	with index <var>end</var>. String indexes are zero based.
      </dd>
      <dt><code>(string.append <var>string1</var> <var>string2</var>)</code></dt>
      <dd>Returns a new string consisting of the concatenation of <var>string1</var> with <var>string2</var>.</dd>
      <dt><code>(string-to-number <var>string</var>)</code></dt>
      <dd>
	Converts <var>string</var> into a corresponding <i>number</i> object. String is interpreted as decimal based
	integer.
      </dd>
      <dt><code>(number-to-string <var>number</var>)</code></dt>
      <dd>Converts <var>number</var> into a <i>string</i> object.
      </dd>
      <dt><code>(ascii <var>number</var>)</code></dt>
      <dd>
	Converts <var>number</var> into a <i>string</i> with one character, which corresponds to the ASCII
	representation of <var>number</var>.
      </dd>
      <dt><code>(ascii-&gt;number <var>string</var>)</code></dt>
      <dd>
	Converts the first character of <var>string</var> into a <i>number</i> which corresponds to its ASCII
	value.
      </dd>
    </dl>

    <h5 id="arithmetic_ops">Arithmetic Operations</h5>

    <dl>
      <dt><code>(+[ <var>arg</var>..])</code></dt>
      <dd>Returns the sum of all <var>arg</var>s or <code>0</code> if none is given.</dd>
      <dt><code>(*[ <var>arg</var>..])</code></dt>
      <dd>Returns the product of all <var>arg</var>s or <code>1</code> if none given.</dd>
      <dt><code>(-[ <var>arg</var>..])</code></dt>
      <dd>
	Returns 0 if no <var>arg</var> is given, -<var>arg</var> if only one is given, <var>arg</var> minus the sum of
	all others otherwise.
      </dd>
      <dt><code>(/ <var>arg</var>[ <var>div</var>..])</code></dt>
      <dd>
	Returns 1/<var>arg</var> if no <var>div</var> is given, <var>arg</var>/<var>div</var>[/<var>div</var>..] if one
	or more <var>div</var>s are given, <code>inf</code> if one of the <var>div</var>s is <code>0</code> and the sum
	of the signs of all operands is even, <code>-inf</code> if it is odd.
      </dd>
      <dt><code>(% <var>arg</var>[ <var>div</var>..])</code></dt>
      <dd>
	Returns <code>1</code> if no <var>div</var> is given, <var>arg</var>%<var>div</var>[%<var>div</var>..] if one or
	more <var>div</var>s are given. If one of the <var>div</var>s is <code>0</code>, the program exits with an
	arithmetic exception.
      </dd>
      <dt><code>(= <var>arg</var>[ <var>arg</var>..])</code></dt>
      <dt><code>(&lt; <var>arg</var>[ <var>arg</var>..])</code></dt>
      <dt><code>(&gt; <var>arg</var>[ <var>arg</var>..])</code></dt>
      <dt><code>(&lt;= <var>arg</var>[ <var>arg</var>..])</code></dt>
      <dt><code>(&gt;= <var>arg</var>[ <var>arg</var>..])</code></dt>
      <dd>
	These predicate functions apply the respective comparison operator between all <var>arg</var>s and return the
	respective result as <code>t</code> or <code>nil</code>.  If only one <var>arg</var> is given they all
	return <code>t</code>.
      </dd>
    </dl>

    <h3 id="editor">Editor Extension</h3>

    <p>The editor extensions introduces several types of objects/functionality:</p>
    <ul>
      <li><dfn>Buffers</dfn> hold text</li>
      <li><dfn>Windows</dfn> display buffer contents to the user</li>
      <li><dfn>Keyboard Input</dfn> allows the user to interact with buffers and windows</li>
      <li>The <dfn>Message Line</dfn> gives feedback to the user</li>
      <li>Several other function for operating system or user interaction</li>
    </ul>

    <h4 id="buffers">Buffers</h4>

    <p>
      This section describes the buffer related functions added by Femto to fLisp. The description is separated in
      function related to buffer management and text manipulation.  Text manipulation always operates on
      the <dfn>current buffer</dfn>. Buffer management creates, deletes buffers, or selects one of the existing buffers
      as the current buffer.
    </p>

    <p>Buffers store text and allow to manipulate it. A buffer has the following properties:</p>
    <dl>
      <dt><var>name</var></dt>
      <dd>
	Buffers are identified by their name. If a buffer name is enclosed in <samp>*</samp>asterisks<samp>*</samp> the
	buffer receives special treatment.
      </dd>
      <dt><var>text</var></dt>
      <dd>zero or more characters.</dd>
      <dt><var>point</var></dt>
      <dd>
	The position in the text where text manipulation takes place. The first position in the text is 0. Note:
	in Emacs the first position is 1.
      </dd>
      <dt><var>mark</var></dt>
      <dd>
	An optional second position in the text. If the <var>mark</var> is set, the text between <var>point</var>
	and <var>mark</var> is called the <dfn>selection</dfn> or <dfn>region</dfn>.
      </dd>
      <dt><var>filename</var></dt>
      <dd>If set the buffer is associated with the respective file.</dd>
      <dt><var>flags</var></dt>
      <dd>Different flags determine the behavior of the buffer.</dd>
    </dl>

    <p>In the following, all mentions of these variables refer to the current buffers properties.</p>
    
    <h5 id="text">Text manipulation</h5>

    <dl>
      <dt><code>(insert-string <var>string</var>)</code></dt>
      <dd>Inserts <var>string</var> before <var>point</var>. <u>S: insert</u>.</dd>
      <dt><code>(insert-file-contents-literally <var>string</var> </code>[<code><var>flag</var></code>]<code>)</code></dt>
      <dd>
	Inserts the file <var>string</var> after <var>point</var>. If <var>flag</var> is not nil the buffer is marked as not
	modified. <u>B</u>
      </dd>
      <dd>
	<p>
	  Note: Currently the flag is forced to nil. The function should
	  return <code>(<var>filename</var> <var>count</var>)</code> but it returns a flag indicating if the operation
	  succeeded.
	</p>
      </dd>
      <dt><code>(erase-buffer)</code></dt>
      <dd>Erases all text in the current buffer. <u>C</u></dd>
      <dt><code>(delete)</code></dt>
      <dd>Deletes the character after <var>point</var>. <u>S: delete-char</u></dd>
      <dt><code>(backspace)</code></dt>
      <dd>Deletes the character to the left of <var>point</var>. <u>S: delete-backward-char</u></dd>
      <dt><code>(get-char)</code></dt>
      <dd>Returns the character at <var>point</var>. <u>S: get-byte</u></dd>
      <dt><code>(copy-region)</code></dt>
      <dd>Copies <var>region</var> to the <var>clipboard</var>. <u>S: copy-region-as-kill</u></dd>
      <dt><code>(kill-region)</code></dt>
      <dd>Deletes the text in the <var>region</var> and copies it to the <var>clipboard</var>. <u>D</u></dd>
      <dt><code>(yank)</code></dt>
      <dd>Pastes the <var>clipboard</var> before <var>point</var>. <u>C</u></dd>
    </dl>

    <h5 id="selection">Selection</h5>

    <dl>
      <dt><code>(set-mark)</code></dt>
      <dd>Sets <var>mark</var> to <var>point</var>. <u>D</u></dd>
      <dt><code>(get-mark)</code></dt>
      <dd>Returns the position of <var>mark</var>, -1 if <var>mark</var> is unset. <u>S: mark</u></dd>
      <dt><code>(get-point)</code></dt>
      <dd>Returns the position of <var>point</var>. <u>S: point</u></dd>
      <dt><code>(get-point-max)</code></dt>
      <dd>Returns the maximum accessible value of point in the current buffer. <u>S: point-max</u></dd>
      <dt><code>(set-clipboard <var>variable</var>)</code></dt>
      <dd><code>Sets <var>clipboard</var> to the contents of <var>variable</var>.</code> <u>S: gui-set-selection</u></dd>
      <dt><code>(get-clipboard)</code></dt>
      <dd>Returns the <var>clipboard</var> contents.  <u>S: gui-get-selection</u></dd>
    </dl>

    <h5 id="cursor">Cursor Movement</h5>

    <dl>
      <dt><code>(set-point <var>number</var>)</code></dt>
      <dd>Sets the point to in the current buffer to the position <var>number</var>. <u>S: goto-char</u></dd>
      <dt><code>(goto-line <var>number</var>)</code></dt>
      <dd>
	Sets the point in the current buffer to the first character on line <var>number</var>. <u>S: goto-line</u>, not
	an Elisp function.
      </dd>
      <dt><code>(search-forward <var>string</var>)</code></dt>
      <dd>
	Searches for <var>string</var> in the current buffer, starting from point forward. If string is found, sets the
	point after the first occurrence of <var>string</var> and returns <samp>t</samp>, otherwise leaves point alone
	and returns <samp>nil</samp>. <u>D</u>
      </dd>
      <dt><code>(search-backward <var>string</var>)</code></dt>
      <dd>
	Searches for <var>string</var> in the current buffer, starting from point backwards. If string is found, sets
	the point before the first occurrence of <var>string</var> and returns <samp>t</samp>, otherwise leaves point
	alone and returns <samp>nil</samp>. <u>D</u>
      </dd>
      <dt><code>(beginning-of-buffer)</code></dt>
      <dd>
	Sets the point in the current buffer to the first buffer position, leaving mark in its current
	position. <u>C</u>
      </dd>
      <dt><code>(end-of-buffer)</code></dt>
      <dd>
	Sets the point in the current buffer to the last buffer position, leaving mark in its current position. <u>C</u>
      </dd>
      <dt><code>(beginning-of-line)</code></dt>
      <dd>
	Sets point before the first character of the current line, leaving mark in its current position. <u>S:
	  move-beginning-of-line</u>
      </dd>
      <dt><code>(end-of-line)</code></dt>
      <dd>
	Sets point after the last character of the current line, i.e. before the end-of-line character sequence, leaving
	mark in its current position. <u>S: move-end-of-line</u>
      </dd>
      <dt><code>(forward-word)</code></dt>
      <dd>
	Moves the point in the current buffer forward before the first char of the next word. If there is no word left
	the point is set to the end of the buffer. If the point is already at the start or within a word, the current
	word is skipped. <u>D</u>: <b>Note</b>: Elisp moves to the <em>end</em> of the the next word.
      </dd>
      <dt><code>(backward-word)</code></dt>
      <dd>
	Moves the point in the current buffer backward after the last char of the previous word. If there is no word
	left the point is set to the beginning of the buffer. If the point is already at the end or within a word, the
	current word is skipped. <u>D</u>: <b>Note</b>: Elisp moves to the <em>beginning</em> of the previous word.
      </dd>
      <dt><code>(forward-char)</code></dt>
      <dd>Moves the point in the current buffer one character forward, but not past the end of the buffer. <u>C</u></dd>
      <dt><code>(backward-char)</code></dt>
      <dd>
	Moves the point in the current buffer one character backward, but not before the end of the
	buffer. <u>C</u>
      </dd> 
      <dt><code>(forward-page)</code></dt>
      <dd>
	Moves the point of the current buffer to the beginning of the last visible line of the associated screen and
	scrolls the screen up to show it as the first line. <u>S: scroll-up</u>
      </dd>
      <dt><code>(backward-page)</code></dt>
      <dd>
	Moves the point of the current buffer to the beginning of the first visible line of the associated screen and
	scrolls the screen down to show it as the last line. <u>S: scroll-down</u>
      </dd>
      <dt><code>(next-line)</code></dt>
      <dd>
	Moves the point in the current buffer to the same character position in the next line, or to the end of the next
	line if there are not enough characters. In the last line of the buffer moves the point to the end of the
	buffer. <u>C</u>
      </dd>
      <dt><code>(previous-line)</code></dt>
      <dd>
	Moves the point in the current buffer to the same character position in the previous line, or to the end of the
	previous line if there are not enough characters. In the first line of the buffer the point is not
	moved. <u>C</u>
      </dd>
    </dl>

    <h5 id="buffer_management">Buffer management</h5>

    <dl>
      <dt><code>(list-buffers)</code></dt>
      <dd>Lists all the buffers in a buffer called <samp>*buffers*</samp>.</dd>
      <dt><code>(get-buffer-count)</code></dt>
      <dd>Returns the number of buffers, includes all special buffers and <samp>*buffers*</samp>.</dd>
      <dt><code>(select-buffer <var>string</var>)</code></dt>
      <dd>Makes the buffer named <var>string</var> the current buffer. Note: <u>C</u> to <code>set-buffer</code> in Elisp.</dd>
      <dt><code>(rename-buffer <var>string</var>)</code></dt>
      <dd>Rename the current buffer to <var>string</var>. <u>C</u></dd>
      <dt><code>(kill-buffer <var>string</var>)</code></dt>
      <dd>Kill the buffer names <var>string</var>. Unsaved changes are discarded. <u>C</u></dd>
      <dt><code>(get-buffer-name)</code></dt>
      <dd>Return the name of the current buffer. Note: <u>C</u> to <code>buffer-name</code> in Elisp.</dd>
      <dt><code>(add-mode-global <var>string</var>)</code></dt>
      <dd>Sets global mode <var>string</var> for all buffers. Currently the only global mode is <kbd>undo</kbd>.</dd>
      <dt><code>(find-file <var>string</var>)</code></dt>
      <dd>Loads file with path string into a new buffer. <u>C</u></dd>
      <dt><code>(save-buffer <var>string</var>)</code></dt>
      <dd>Saves the buffer named <var>string</var> to disk. <u>C</u></dd>
    </dl>

    <h4 id="ui">User Interaction</h4>

    <p>
      This section lists function related to window and message line manipulation, keyboard input and system
      interaction.
    </p>

    <h5 id="windows">Window Handling</h5>

    <dl>
      <dt><code>(delete-other-windows)</code></dt>
      <dd>Make current window the only window. <u>C</u></dd>
      <dt><code>(split-window)</code></dt>
      <dd>Splits the current window. Creates a new window for the current buffer. <u>C</u></dd>
      <dt><code>(other-window)</code></dt>
      <dd>
	Moves the cursor to the next window down on the screen. Makes the buffer in that window the current
	buffer. <u>D</u>
      </dd> 
      <dd>
	<p>Note: Elisp <code>other-window</code> has a required parameter <var>count</var>, which specifies the number
	  of windows to move down or up.
	</p>
      </dd>
      <dt><code>(update-display)</code></dt>
      <dd>Updates all modified windows.</dd>
      <dt><code>(refresh)</code></dt>
      <dd>Updates all windows by marking them modified and calling <code>update-display</code>.</dd>
    </dl>

    <h5 id="message_line">Message Line</h5>
    <dl>
      <dt><code>(message <var>string</var>)</code></dt>
      <dd>Displays <var>string</var> in the message line. <u>D</u></dd>
      <dt><code>(clear-message-line)</code></dt>
      <dd>Displays the empty string in the message line.</dd>
      <dt><code>(prompt <var>prompt</var> <var>default</var>)</code></dt>
      <dd>
	Displays <var>prompt</var> in the command line and sets <var>default</var> as initial value for the user
	response. The user can edit the response. When hitting return, the final response is returned.
      </dd>
      <dt><code>(show-prompt <var>prompt</var> <var>default</var>)</code></dt>
      <dd>
	Displays <var>prompt</var> and <var>default</var> in the command line, but does not allow
	editing. Returns <code>t</code>.
      </dd>
      <dt><code>(prompt-filename <var>prompt</var>)</code></dt>
      <dd>
	Displays <var>prompt</var> in the command line and allows to enter or search for a file name. Returns the
	relative path to the selected file name or the response typed by the user.
      </dd>
    </dl>

    <h5 id="keyboard">Keyboard Handling</h5>

    <dl>
      <dt><code>(set-key <var>key-name</var> <var>lisp-func</var>)</code></dt>
      <dd>Binds key key-name to the lisp function <var>lisp-func</var>.</dd>
      <dt><code>(get-key-name)</code></dt>
      <dd>Returns the name of the currently pressed key, eg: <samp>c-k</samp> for control-k.</dd>
      <dt><code>(get-key-funcname)</code></dt>
      <dd>Return the name of the function bound to the currently pressed key.</dd>
      <dt><code>(execute-key)</code></dt>
      <dd>Executes the function of the last bound key. <mark>Tbd. bound or pressed?</mark></dd>
      <dt><code>(describe-bindings)</code></dt>
      <dd>
	Creates a listing of all current key bindings, in a buffer named <samp>*help*</samp> and displays it in a new
	window. <u>C</u>
      </dd>
      <dt><code>(describe-functions)</code></dt>
      <dd>
	Creates a listing of all functions bound to keys in a buffer named <samp>*help*</samp> and displays it in a new
	window.
      </dd>
      <dt><code>(getch)</code></dt>
      <dd>
	Waits for a key to be pressed and returns the key as string. See
	also <code>get-key-name</code>, <code>get-key-funcname</code> and <code>execute-key</code>.
      </dd>
    </dl>

    <h5 id="programming_system">Programming and System Interaction</h5>

    <dl>
      <dt><code>(exit)</code></dt>
      <dd>Exit Femto without saving modified buffers.</dd>
      <dt><code>(eval-block)</code></dt>
      <dd>
	Evaluates the <var>region</var> in the current buffer, inserts the result at <var>point</var> and returns
	it. If <var>mark</var> in the current buffer is before <var>point</var> <code>eval-block</code> evaluates
	this <var>region</var> and inserts the result at <var>point</var>. If <var>point</var> is
	before <var>mark</var> <code>eval-block</code> does nothing but returning <samp>t</samp>.
      </dd>
      <dt><code>(system <var>string</var>)</code></dt>
      <dd>
	Executes the <a href="https://man7.org/linux/man-pages/man3/system.3.html">system(1)</a> function
	with <var>string</var> as parameter.
      </dd>
      <dt><code>(os.getenv <var>string</var>) </code></dt>
      <dd>Returns the value of the environment variable named <var>string</var>.</dd>
      <dt><code>(log-message <var>string</var>)</code></dt>
      <dd>Logs <var>string</var> to the <samp>*messages*</samp> buffer. </dd>
      <dt><code>(log-debug <var>string</var>)</code></dt>
      <dd>Logs string to the file <code>debug.out</code>.</dd>
      <dt><code>(get-version-string)</code></dt>
      <dd>Returns the complete version string of Femto, including the copyright.</dd>
    </dl>
    

    <h3 id="exceptions">Error handling</h3>
    <p>
      Whenever fLisp encounters an error an exception is thrown. Exceptions have a non-zero result code and an error
      message.  The error message is a string containing the serialization of the object causing the error — if any —
      and an individual user readable string.
    </p>
    <p>
      fLisp does not implement stack backtracking. exceptions are only caught on the top level of an evaluation.
    </p>
    <p>Exceptions can be thrown in Lisp code via the <a href="#interp_ops"><code>signal</code></a> function.</p>
    <p>
      <mark>Note: currently the error result code is always 1. It is planned to distinguish different error classes,
	e.g. parsing errors, execution errors, I/O errors, input errors, …
      </mark>
    </p>
    <h3 id="embedding">Embedding fLisp</h3>
    <p>
      fLisp exposes the following public interfaces:
    </p>
    <dl>
      <dt><code><var>Interpreter</var> *lisp_init(int <var>argc</var>, char **<var>argv</var>, char
	  *<var>library_path</var>)</code></dt>
      <dd>
	<p><code>lisp_init()</code> creates and initializes an fLisp interpreter.  The initial environment contains the
	  following symbols:
	</p>
	<dl>
	  <dt><var>argv0</var></dt><dd>The string stored in <code>*<var>argv</var>[0]</code>, if any</dd>
	  <dt><var>argv</var></dt><dd>The list of strings stored in <code><var>argv</var></code></dd>
	  <dt><var>script_dir</var></dt><dd>The string stored in <code><var>library_path</var></code></dd>
	</dl>
	<p>A pointer to an <var>Interpreter</var> struct is returned, which is used to operate the interpreter.</p>
      </dd>
      <dt><code><var>ResultCode</var> lisp_eval(<var>interp</var>, <var>format</var>, …)</code></dt>
      <dd>
	<p>
	  Evaluates input in the fLisp interpreter <var>interp</var>.  The input is generated the same way as
	  in <code>printf()</code> from the <var>format</var> string and any following optional arguments.
	</p>
	<p>
	  The <var>ResultCode</var> is <code>0</code> when the input is evaluated successfully and non-zero if any error
	  occurred during evaluation.  The result code is also stored in <var>interp-&gt;result</var>.
	</p>
	<p>
	  After evaluation <var>interp-&gt;output</var> contains the output of the evaluation
	  and <var>interp-&gt;message</var> contains the error message if result code is non-zero.
      </dd>
    </dl>
    <p><mark>Note: currently only one interpreter can be created.</mark></p>
    
    <h3 id="implementation">Implementation Details</h3>

    <h4 id="gc">Garbage Collection</h4>
    <p>
      fLisp implements Cheney&apos;s copying garbage collector, with which memory is divided into two equal halves
      (semi spaces): from- and to-space. From-space is where new objects are allocated, whereas to-space is used during
      garbage collection.
    </p>
    <p>
      When garbage collection is performed, objects that are still in use (live) are copied from from-space to
      to-space. To-space then becomes the new from-space and vice versa, thereby discarding all objects that have not
      been copied.
    </p>
    <p>
      Our garbage collector takes as input a list of root objects. Objects that can be reached by recursively traversing
      this list are considered live and will be moved to to-space. When we move an object, we must also update its
      pointer within the list to point to the objects new location in memory.
    </p>
    <p>
      However, this implies that our interpreter cannot use raw pointers to objects in any function that might trigger
      garbage collection (or risk causing a SEGV when accessing an object that has been moved). Instead, objects must be
      added to the list and then only accessed through the pointer inside the list.
    </p>
    <p>
      Thus, whenever we would have used a raw pointer to an object, we use a pointer to the pointer inside the list
      instead:
    </p>
    <pre>
function:              pointer to pointer inside list (Object **)
                               |
                               v
list of root objects:  pointer to object (Object *)
                               |
                               v
semi space:             object in memory
    </pre>
    <p>
      <code><var>GC_ROOTS</var></code> and <code><var>GC_PARAM</var></code> are used to pass the list from function to
      function.
    </p>
    <p>
      <code><var>GC_TRACE</var></code> adds an object to the list and declares a variable which points to the objects
      pointer inside the list.
    </p>
    <p>
      <code><var>GC_TRACE</var>(<var>gcX</var>, <var>X</var>)</code>: add object <var>X</var> to the list and
      declare <code>Object **<var>gcX</var></code> to point to the pointer to <var>X</var> inside the list.
    </p>
    <h4 id="memory">Memory Usage</h4>
    <p>
      Some compile time adjustable limits in <code>lisp.h</code>:
    </p>
    <dl>
      <dt>Object memory</dt><dd>4M, <code>FLISP_MEMORY_SIZE</code>.</dd>
      <dt>Input buffer</dt><dd>2048, <code>INPUT_FMT_BUFSIZ</code>, size of the formatting buffer for <code>lisp_eval()</code>.</dd>
      <dt>Output buffer</dt><dd>2048, <code>WRITE_FMT_BUFSIZ</code>, size of the output and message formatting buffer.</dd>
    </dl>
    <p>
      fLisp can live with much less object memory, but the <q>OXO</q> game requires a lot and <mark>the garbage
	collector has a bug</mark> which makes OXO segfault.
    </p>

    <h4 id="future">Future Directions</h4>
    <p>
      fLisp could be made completely independent of Femto, thus making the interpreter embeddable in any
      application. The <code>debug()</code> function is still borrowed from <code>main.c</code> and it has to be devised
      how to extend the interpreter dynamically; the editor extensions are currently compiled into the interpreter.
    </p>
    <p>
      Integer arithmetic would be sufficient for all current purposes and increase portability, speed while reducing
      size.
    </p>
    <p>
      The internally used <q>Stream</q> abstraction for reading Lisp input and writing output is incomplete and
      complicated. An alternative would be to use only string input and output. File input can be read as a whole into
      memory and use the string input processing.  This would also have consequences for the Lisp reader and probably
      simplify implementation of improved error reporting, a lá line/char offset reporting.  The downside is, that this
      would remove support for <code>stdin</code>/<code>stdout</code> reading/writing.
    </p>
    <p>
      Exception handling should be improved by returning differentiated error codes. One of the benefits would be the
      possibility to implement externally an interactive repl with <code>stdin</code>/<code>stdout</code> streams, by
      reading and eval&apos;ing until no more <q>incomplete input</q> result codes are returned.
    </p>
    
  </body>
</html>
<!--
    Emacs:
    Local Variables:
    fill-column: 120
    End:
  -->
